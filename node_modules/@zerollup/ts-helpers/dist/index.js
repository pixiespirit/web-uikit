'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var path = require('path');
var ts = _interopDefault(require('typescript'));

function regExpEscape(s) {
    return s.replace(/[\\^$*+?.()|[\]{}]/g, '\\$&');
}
var Tokenizer = /** @class */ (function () {
    function Tokenizer(pathKey, subs, tokens) {
        var _this = this;
        if (tokens === void 0) { tokens = ['*']; }
        this.subs = subs;
        this.tokens = [];
        var tokenMask = new RegExp("(" + tokens.map(regExpEscape).join('|') + ")", 'g');
        var mask = pathKey.replace(tokenMask, function (token) {
            _this.tokens.push(new RegExp(regExpEscape(token), 'g'));
            return '><';
        });
        this.mask = new RegExp('^' + regExpEscape(mask).replace(/\>\</g, '(?!\\.\\/)(.*)') + '$');
    }
    Tokenizer.prototype.parse = function (str) {
        var _a = this, mask = _a.mask, tokens = _a.tokens, subs = _a.subs;
        var match = str.match(mask);
        if (match) {
            var parsedSubs = [];
            for (var _i = 0, subs_1 = subs; _i < subs_1.length; _i++) {
                var sub = subs_1[_i];
                for (var i = 1; i < match.length; i++) {
                    var token = tokens[i - 1];
                    var replacement = match[i];
                    sub = sub.replace(token, replacement);
                }
                parsedSubs.push(sub);
            }
            return parsedSubs;
        }
    };
    return Tokenizer;
}());

var winSepRegex = new RegExp(regExpEscape(path.sep), 'g');
var posixSepRegex = /\//g;
var ImportPathsResolver = /** @class */ (function () {
    function ImportPathsResolver(opts) {
        var paths = opts.paths || {};
        var baseUrl = this.baseUrl = opts.baseUrl ? opts.baseUrl.replace(winSepRegex, '\/') : '';
        var mapBaseUrl = baseUrl
            ? function (sub) { return (sub[0] === '/'
                ? sub
                : baseUrl + "/" + (sub.substring(0, 2) === './' ? sub.substring(2) : sub)); }
            : undefined;
        this.tokenizers = Object.keys(paths)
            .filter(function (key) { return !opts.exclude || !opts.exclude.includes(key); })
            .map(function (key) { return new Tokenizer(key, mapBaseUrl ? paths[key].map(mapBaseUrl) : paths[key]); });
    }
    ImportPathsResolver.prototype.getImportSuggestions = function (oldImport, fileName) {
        if (isRelative(oldImport))
            return;
        for (var _i = 0, _a = this.tokenizers; _i < _a.length; _i++) {
            var tokenizer = _a[_i];
            var match = tokenizer.parse(oldImport);
            if (match) {
                return match.map(function (p) {
                    var newPath = path.relative(fileName, p.replace(posixSepRegex, path.sep)).replace(winSepRegex, '\/');
                    return isRelative(newPath) ? newPath : ('./' + newPath);
                });
            }
        }
        var defaultPath = path.relative(fileName, this.baseUrl + '/' + oldImport).replace(winSepRegex, '\/');
        return [isRelative(defaultPath) ? defaultPath : ('./' + defaultPath)];
    };
    return ImportPathsResolver;
}());
function isRelative(fileName) {
    return fileName === '.' || fileName.startsWith('./') || fileName.startsWith('../');
}

var Replacer = /** @class */ (function () {
    function Replacer(sourceText) {
        this.sourceText = sourceText;
        this.items = [];
    }
    Replacer.prototype.push = function (item) {
        this.items.push(item);
    };
    Replacer.prototype.getReplaced = function () {
        var _a = this, items = _a.items, sourceText = _a.sourceText;
        if (items.length === 0)
            return;
        var result = '';
        var pos = 0;
        for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
            var item = items_1[_i];
            result += sourceText.substring(pos, item.start) + item.replacement;
            pos = item.start + item.length;
        }
        result += sourceText.substring(pos);
        return result;
    };
    return Replacer;
}());

function createTraverseVisitor(traverseVisitor, visitorContext, ctx) {
    return function visitor(node) {
        return traverseVisitor(node, visitorContext) || ts.visitEachChild(node, visitor, ctx);
    };
}

exports.ImportPathsResolver = ImportPathsResolver;
exports.Replacer = Replacer;
exports.Tokenizer = Tokenizer;
exports.createTraverseVisitor = createTraverseVisitor;
exports.posixSepRegex = posixSepRegex;
exports.regExpEscape = regExpEscape;
exports.winSepRegex = winSepRegex;
//# sourceMappingURL=index.js.map
